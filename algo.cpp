#include <iostream>
#include <vector>

void print(std::vector<int> &vector) {
    for (auto elem : vector)
        std::cout << elem << " ";
    std::cout << "\n";
}

int main() {
    size_t N = 0;
    std::cin >> N;
    // Последовательность 1
    std::vector<int> sequenceFirst(N);
    for (size_t i = 0; i != N; ++i)
        std::cin >> sequenceFirst[i];
    size_t M = 0;
    std::cin >> M;
    // Последовательность 2
    std::vector<int> sequenceSecond(M);
    for (size_t i = 0; i != M; ++i)
        std::cin >> sequenceSecond[i];
    // Таблица размера (n+1)(m+1)(+1 для того, чтобы не вылететь за границу) для сохранения сохранения размера общей подстроки на последовательностях размера
    // N - i - 1 и N - j - 1. То есть мы разбили задачу на подзадачи, каждая из которых решает задачу нахождения длины
    // общей подпоследовательности на соответствующем шаге.
    std::vector<std::vector<int>> max_sequence(N + 1, std::vector<int>(M + 1));
    for (size_t i = 0; i != N; ++i) {
        for (size_t j = 0; j != M; ++j) {
            // Начинаем с конца(так удобнее, ответ будет сверху слева). Действительно, если два элемента совпадают, значит они принадлежат общей
            // подпоследовательности. Откуда следует, что длина меньшей подзадачи(та, что находится в таблице ниже по diag)
            // будет равна 1 + предыдущий размер(так как общая подпоследовательность увеличилась на 1)
            if (sequenceFirst[N - i - 1] == sequenceSecond[M - j - 1]) {
                max_sequence[N - i - 1][M - j - 1] = 1 + max_sequence[N - i][M - j];
                // Если же последние символы не равны на соотв. шаге, то берем соседний снизу или справа(так как нам нужна
                // максимальная подпоследовательность, то ставим на ячейку то, что было либо на предыдущем шаге для i и j
            } else {
                max_sequence[N - i - 1][M - j - 1] = std::max(max_sequence[N - i][M - j - 1],
                                                              max_sequence[N - i - 1][M - j]);
            }
        }
    }
    // По сути своей, мы бегали по таблице результатов и считали длину общей подпоследовательности на i-ом и j-ом шаге,
    // тем самым мы запоминали ее длину на соответстующих шагах. Сейчас мы будем использовать таблицу для восстановления
    // исходной подпоследовательности. Будем двигаться по соответствующим направлениям следующим образом:
    // начинаем с 0 0, если там не 0(значит длина есть), смотрим на i в первой и j на во второй, если они совпадают, то
    // пушим в вектор, пока совпадают. Иначе, смотрим на правый символ в одной из подпоследовательностей. Если нынешний
    // совпадают со следующим, двигаем направо соответствующее слово(если в какой-то момент в таблице стало 0, значит
    // подпоследовательность закончилась.
    std::vector<int> result;
    for (size_t i = 0, j = 0; max_sequence[i][j] != 0 && i < sequenceFirst.size() && j < sequenceSecond.size();) {
        //
        if (sequenceFirst[i] == sequenceSecond[j]) {
            result.push_back(sequenceFirst[i]);
            ++i;
            ++j;
        } else {
            if (max_sequence[i][j] == max_sequence[i + 1][j]) {
                ++i;
            } else {
                ++j;
            }
        }
        std::cout << "i:" << i << " " << "j:" << j << "\n";
        print(result);
    }
    for (auto &elem : result)
        std::cout << elem << " ";
}

// Визуализация для условия !=
// input
// 3
// 1 2 3
// 3
// 2 3 1
//   i = 0; j = 0
//   1 != 2:
//    1 2 3 N
//  2 0 0 0 0
//  3 0 0 0 0
//  1 0 0 0 0
//  N 0 0 0 0
//
//    i = 0; j = 2
//    1 2 3 N
//  2 0 0 0 0
//  3 0 0 0 0
//  1 1 1 0 0
//  N 0 0 0 0
//  Видим, что в таблице на i = 2, j = 0 и 1 появилась 1. Действительно, посмотрим на соответствующие подпоследовательности:
//  12{3} 2{31}. Для подпоследовательностей 3 и 31 общая - {3} = длина 1. Причем и для {23} и {31}(что и учитывает движение вниз или влево)

// Теперь визуализируем результат для 123 и 231:
//    пошли направо по таблице и по первому слову(рассматриваем 23 и 231
//    i:1 j:0
//
//    пошли направо и вниз по таблице(соответственно {2}3 и {2}31
//    i:2 j:1
//    2
//    снова (соответственно {23} и {23}1)
//    i:3 j:2
//    2 3

// Что вообще происходило? Ответ:
// 1 2 3 | => 1 2 3
// 2 3 1 | =>   2 3 1
